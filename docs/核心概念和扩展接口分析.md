# Red Jasmine 电商系统扩展点设计规范

## 文档说明

本文档定义了 Red Jasmine 电商系统的核心扩展点，帮助开发者基于系统进行二次开发和功能扩展。所有扩展点均通过接口定义和管理器注册的方式实现，确保系统的可扩展性和稳定性。

## 核心设计方案：接口驱动的类型系统

### 设计理念

Red Jasmine 采用**纯接口驱动**的设计，**不定义核心枚举**，所有类型地位平等：

- **接口定义**：定义类型的行为契约

- **实现类**：每种类型是一个独立的实现类

- **管理器**：统一注册和管理所有类型

- **字符串标识**：所有类型使用字符串作为唯一标识

### 架构图示

```

┌─────────────────────────────────────────────────────────────┐

│                    核心包 (ecommerce)                        │

│  ┌──────────────────────────────────────────────────────┐   │

│  │ 接口定义：定义类型行为契约                             │   │

│  │ interface ProductTypeInterface {                      │   │

│  │   public function type(): string;                     │   │

│  │   public function label(): string;                    │   │

│  │   public function requiresInventory(): bool;          │   │

│  │   // ... 更多业务逻辑方法                              │   │

│  │ }                                                     │   │

│  └──────────────────────────────────────────────────────┘   │

│                                                              │

│  ┌──────────────────────────────────────────────────────┐   │

│  │ 内置实现：提供默认的类型实现                           │   │

│  │ class PhysicalProductType implements Interface { }    │   │

│  │ class VirtualProductType implements Interface { }     │   │

│  │ class ServiceProductType implements Interface { }     │   │

│  └──────────────────────────────────────────────────────┘   │

│                                                              │

│  ┌──────────────────────────────────────────────────────┐   │

│  │ 管理器：统一注册和管理所有类型                         │   │

│  │ class ProductTypeManager {                            │   │

│  │   protected const PROVIDERS = [                       │   │

│  │     'physical' => PhysicalProductType::class,         │   │

│  │     'virtual' => VirtualProductType::class,           │   │

│  │   ];                                                  │   │

│  │   public static function register(string, class)      │   │

│  │   public static function getAllTypes(): array         │   │

│  │ }                                                     │   │

│  └──────────────────────────────────────────────────────┘   │

└────────────────────────┬─────────────────────────────────────┘

                         │ 完全平等扩展

                         ▼

┌─────────────────────────────────────────────────────────────┐

│              扩展包/应用层 (hotel-plugin)                     │

│  ┌──────────────────────────────────────────────────────┐   │

│  │ 扩展实现：与内置类型地位完全平等                       │   │

│  │ class HotelProductType implements ProductTypeInterface│   │

│  │ {                                                     │   │

│  │   public function type(): string {                    │   │

│  │     return 'hotel';                                   │   │

│  │   }                                                   │   │

│  │   public function label(): string {                   │   │

│  │     return '酒店';                                    │   │

│  │   }                                                   │   │

│  │   // ... 实现业务逻辑                                  │   │

│  │ }                                                     │   │

│  └──────────────────────────────────────────────────────┘   │

│                                                              │

│  ┌──────────────────────────────────────────────────────┐   │

│  │ 注册：动态注册到管理器                                 │   │

│  │ ProductTypeManager::register('hotel',                 │   │

│  │     HotelProductType::class);                         │   │

│  └──────────────────────────────────────────────────────┘   │

└─────────────────────────────────────────────────────────────┘

```

### 核心优势

1. ✅ **完全平等**：内置类型和扩展类型地位相同

2. ✅ **零侵入**：无需修改任何核心代码

3. ✅ **无枚举限制**：不存在枚举的封闭性问题

4. ✅ **易升级**：核心包升级不影响扩展

5. ✅ **灵活扩展**：任意类型使用字符串自由命名

### 职责划分

**接口（Interface）**

- 定义类型的行为契约

- 规范所有类型必须实现的方法

- 提供类型安全的约束

**实现类（Implementation）**

- 核心包提供内置类型的默认实现

- 扩展包提供自定义类型的实现

- 所有实现地位完全平等

**管理器（Manager）**

- 统一注册所有类型

- 提供类型的创建和查询

- 管理类型的生命周期

**字符串标识（String Identifier）**

- 所有类型使用字符串作为唯一标识

- 数据库字段存储字符串值

- 支持任意命名

### 使用示例

```php
// ✅ 所有类型统一使用字符串标识
$product->type = 'physical';  // 内置类型
$product->type = 'hotel'; // 扩展类型
// 两者地位完全平等

// ✅ 验证：使用管理器获取所有已注册类型
'product_type' => ['required', Rule::in(ProductTypeManager::getAllTypes())],
// 返回：['physical', 'virtual', 'hotel', 'ticket', ...]

// ✅ 获取标签：统一通过管理器
$label = ProductTypeManager::create($product->type)->label();

// ✅ 业务逻辑：统一使用接口
$handler = ProductTypeManager::create($product->type);
$handler->validateProductData($data);

if ($handler->requiresInventory()) {
    // 处理库存
}
```

## 扩展点设计原则

### 1. SOLID 设计原则

- **单一职责**：接口、实现类、管理器各司其职

- **开闭原则**：核心代码对修改关闭，对扩展开放

- **里氏替换**：所有类型实现可以互相替换

- **接口隔离**：接口小而精，职责明确

- **依赖倒置**：依赖抽象接口，不依赖具体实现

### 2. 架构模式

- **策略模式**：每种类型都是一个独立的策略实现

- **工厂模式**：使用管理器统一创建和管理类型实例

- **注册器模式**：支持运行时动态注册扩展类型

- **模板方法**：通过抽象基类提供通用实现模板

### 3. 核心机制

- **接口驱动**：所有类型必须实现统一的接口

- **字符串标识**：所有类型使用字符串作为唯一标识

- **依赖注入**：通过 Laravel 容器实现自动注入

- **钩子扩展**：在关键节点提供钩子机制

- **事件驱动**：使用领域事件解耦业务逻辑

- **无枚举设计**：不使用枚举，避免封闭性限制

### 4. 扩展点组成要素

每个完整的扩展点应包含：

- **接口定义** (Interface): 定义扩展点的契约

- **抽象基类** (Abstract): 提供通用实现和模板方法

- **管理器** (Manager/Factory): 管理扩展实现的注册和创建

- **默认实现** (Default): 提供开箱即用的内置类型实现

### 5. 命名规范

- **接口**: `{概念}Interface` 或 `{概念}HandlerInterface`

- **抽象类**: `Abstract{概念}Handler` 或 `Abstract{概念}`

- **管理器**: `{概念}Manager` 或 `{概念}Factory`

- **具体实现**: `{具体类型}{概念}Type` 或 `{具体类型}{概念}Handler`

### 6. 接口驱动设计

**核心理念：不使用枚举，完全通过接口和管理器实现类型系统**

#### 设计原则

- ✅ **无枚举设计**：不定义类型枚举，避免封闭性

- ✅ **接口契约**：所有类型必须实现统一的接口

- ✅ **字符串标识**：所有类型使用字符串作为唯一标识

- ✅ **平等扩展**：内置类型和扩展类型地位完全平等

- ✅ **管理器统一**：通过管理器注册、创建、查询所有类型

#### 类型系统结构

```php
// 1. 接口定义（核心包）
interface ProductTypeInterface
{
    public function type(): string;      // 类型标识
    public function label(): string;     // 显示标签
    public function icon(): ?string;     // 图标
    public function requiresInventory(): bool;  // 是否需要库存
    public function requiresShipping(): bool;   // 是否需要物流
    // ... 更多业务逻辑方法
}

// 2. 内置类型实现（核心包）
class PhysicalProductType implements ProductTypeInterface
{
    public function type(): string
    {
        return 'physical';  // 直接返回字符串
    }

    public function label(): string
    {
        return '实物商品';
    }

    public function requiresInventory(): bool
    {
        return true;
    }

    public function requiresShipping(): bool
    {
        return true;
    }
}

// 3. 扩展类型实现（扩展包/应用层）- 与内置类型完全平等
class HotelProductType implements ProductTypeInterface
{
    public function type(): string
    {
        return 'hotel';
    }

    public function label(): string
    {
        return '酒店';
    }

    public function requiresInventory(): bool
    {
        return false;  // 酒店不需要传统库存
    }

    public function requiresShipping(): bool
    {
        return false;  // 酒店不需要物流
    }
}

// 4. 管理器（核心包）
class ProductTypeManager extends ServiceManager
{
    // 内置类型
    protected const PROVIDERS = [
        'physical' => PhysicalProductType::class,
        'virtual' => VirtualProductType::class,
        'service' => ServiceProductType::class,
        'digital' => DigitalProductType::class,
    ];

    /**
     * 注册扩展类型
     */
    public static function register(string $type, string|Closure $handler): void;

    /**
     * 获取所有已注册类型
     */
    public static function getAllTypes(): array
    {
        return array_keys(static::getInstance()->providers());
    }

    /**
     * 获取类型标签映射
     */
    public static function getTypeLabels(): array
    {
        $labels = [];
        foreach (static::getAllTypes() as $type) {
            $labels[$type] = static::create($type)->label();
        }
        return $labels;
    }

    /**
     * 检查类型是否存在
     */
    public static function exists(string $type): bool
    {
        return in_array($type, static::getAllTypes());
    }
}
```

#### 使用示例

```php
// ✅ 注册扩展类型（在 ServiceProvider 中）
ProductTypeManager::register('hotel', HotelProductType::class);
ProductTypeManager::register('ticket', TicketProductType::class);

// ✅ 数据库存储：统一使用字符串
$product->type = 'physical';  // 内置类型
$product->type = 'hotel';     // 扩展类型
// 两者完全平等，没有区别

// ✅ 表单验证：使用管理器
'type' => ['required', Rule::in(ProductTypeManager::getAllTypes())],
// 返回所有已注册类型：['physical', 'virtual', 'hotel', 'ticket', ...]

// ✅ 获取标签：统一通过管理器
$label = ProductTypeManager::create($product->type)->label();

// ✅ 业务逻辑：统一使用接口
$handler = ProductTypeManager::create($product->type);

if ($handler->requiresInventory()) {
    // 处理库存
}

if ($handler->requiresShipping()) {
    // 处理物流
}

// ✅ 下拉选项：从管理器获取
$options = ProductTypeManager::getTypeLabels();
// ['physical' => '实物商品', 'virtual' => '虚拟商品', 'hotel' => '酒店', ...]
```

#### 数据库设计

```php
// 数据库迁移：使用字符串字段
$table->string('type', 64)->comment('商品类型');

// 动态生成注释（可选）
$types = ProductTypeManager::getTypeLabels();
$comment = '商品类型: ' . implode(', ', array_map(
    fn($k, $v) => "{$k}={$v}",
    array_keys($types),
    array_values($types)
));
$table->string('type', 64)->comment($comment);
```

---

## 一、商品领域扩展点

### 1.1 商品类型扩展 (ProductTypeInterface)

#### 业务场景

不同类型的商品具有不同的业务逻辑：

- 实物商品需要物流配送

- 虚拟商品无需物流

- 服务类商品需要预约

- 预定类商品（酒店、门票等）需要时间段管理

#### 内置类型

| 类型标识 | 名称 | 说明 |

|---------|------|-----|

|  `physical`  | 实物商品 | 需要物流配送 |

|  `virtual`  | 虚拟商品 | 无需物流 |

|  `service`  | 服务商品 | 需要预约 |

|  `digital`  | 数字卡密 | 自动发货 |

|  `coupons`  | 卡券 | 优惠券类 |

|  `booking`  | 预定商品 | 时间段管理 |

#### 接口定义

```php

namespace RedJasmine\Ecommerce\Domain\Contracts;

/**

 * 商品类型接口

 */

interface ProductTypeInterface

{

 /**

     * 获取商品类型标识（唯一字符串）

     */

 public  function  type(): string;

 /**

     * 获取商品类型标签

     */

 public  function  label(): string;

 /**

     * 获取商品类型图标

     */

 public  function  icon(): ?string;

 /**

     * 获取商品类型提示信息

     */

 public  function  tips(): ?string;

 /**

     * 获取允许的发货类型

* @return  array<string>

     */

 public  function  getFulfillmentMethods(): array;

 /**

     * 获取默认发货类型

     */

 public  function  getDefaultShippingType(): string;

 /**

     * 是否需要收货地址

     */

 public  function  requiresDeliveryAddress(): bool;

 /**

     * 是否需要库存管理

     */

 public  function  requiresInventory(): bool;

 /**

     * 是否需要物流跟踪

     */

 public  function  requiresShipping(): bool;

 /**

     * 是否需要时间预约（如酒店入住时间）

     */

 public  function  requiresTimeBooking(): bool;

 /**

     * 是否需要实名认证

     */

 public  function  requiresRealName(): bool;

 /**

     * 获取商品特有的扩展字段定义

* @return  array ['field_name' => 'field_type']

     */

 public  function  getExtensionFields(): array;

 /**

     * 验证商品数据

* @throws  \InvalidArgumentException

     */

 public  function  validateProductData(array  $data): void;

 /**

     * 商品创建前的处理

     */

 public  function  onProductCreating($product): void;

 /**

     * 商品创建后的处理

     */

 public  function  onProductCreated($product): void;

 /**

     * 商品上架前的处理

     */

 public  function  onProductPublishing($product): void;

 /**

     * 获取价格计算策略

     */

 public  function  getPriceCalculator(): ?string;

 /**

     * 获取库存计算策略

     */

 public  function  getInventoryCalculator(): ?string;

}

```

#### 管理器设计

```php

namespace RedJasmine\Ecommerce\Domain\Services;

use RedJasmine\Support\Foundation\Manager\ServiceManager;

use RedJasmine\Ecommerce\Domain\Contracts\ProductTypeInterface;

class ProductTypeManager extends ServiceManager

{

 /**

     * 核心包提供的内置类型

     */

 protected  const  PROVIDERS = [

 'physical' => PhysicalProductType::class,

 'virtual' => VirtualProductType::class,

 'service' => ServiceProductType::class,

 'digital' => DigitalProductType::class,

 'coupons' => CouponsProductType::class,

 'booking' => BookingProductType::class,

    ];

 /**

     * 注册新的商品类型（扩展包/应用层使用）

     */

 public  static  function  register(string  $type, string|Closure $handler): void;

 /**

     * 批量注册商品类型

     */

 public  static  function  registerMany(array  $types): void

    {

 foreach ($types  as  $type => $handler) {

 static::register($type, $handler);

        }

    }

 /**

     * 创建商品类型实例

     */

 public  function  create(string  $type): ProductTypeInterface;

 /**

     * 获取所有已注册的商品类型（包括内置和扩展）

     */

 public  static  function  getAllTypes(): array

    {

 return  array_keys(static::getInstance()->providers());

    }

 /**

     * 获取所有商品类型的标签映射

     */

 public  static  function  getTypeLabels(): array

    {

 $labels = [];

 foreach (static::getAllTypes() as  $type) {

 try {

 $handler = static::create($type);

 $labels[$type] = $handler->label();

} catch (\Exception $e) {

 continue;

            }

        }

 return  $labels;

    }

 /**

     * 获取所有商品类型的图标映射

     */

 public  static  function  getTypeIcons(): array

    {

 $icons = [];

 foreach (static::getAllTypes() as  $type) {

 try {

 $handler = static::create($type);

 $icons[$type] = $handler->icon();

} catch (\Exception $e) {

 continue;

            }

        }

 return  $icons;

    }

 /**

     * 检查类型是否存在

     */

 public  static  function  exists(string  $type): bool

    {

 return  in_array($type,  static::getAllTypes());

    }

 /**

     * 判断是否为内置类型

     */

 public  static  function  isBuiltin(string  $type): bool

    {

 return  array_key_exists($type,  static::PROVIDERS);

    }

 /**

     * 获取内置类型列表

     */

 public  static  function  getBuiltinTypes(): array

    {

 return  array_keys(static::PROVIDERS);

    }

 /**

     * 获取类型的完整信息

     */

 public  static  function  getTypeInfo(string  $type): array

    {

 if (!static::exists($type)) {

 throw  new  \InvalidArgumentException("商品类型 [{$type}] 不存在");

        }

 $handler = static::create($type);

 return [

 'type' => $type,

 'label' => $handler->label(),

 'icon' => $handler->icon(),

 'is_builtin' => static::isBuiltin($type),

 'requires_inventory' => $handler->requiresInventory(),

 'requires_shipping' => $handler->requiresShipping(),

 'requires_time_booking' => $handler->requiresTimeBooking(),

 'extension_fields' => $handler->getExtensionFields(),

        ];

    }

 /**

     * 获取所有类型的详细信息

     */

 public  static  function  getAllTypesInfo(): array

    {

 $info = [];

 foreach (static::getAllTypes() as  $type) {

 try {

 $info[$type] = static::getTypeInfo($type);

} catch (\Exception $e) {

 continue;

            }

        }

 return  $info;

    }

 /**

     * 获取满足条件的类型列表

     */

 public  static  function  getTypesBy(callable  $filter): array

    {

 return  array_filter(

 static::getAllTypes(),

 function($type)  use  ($filter)  {

 try  {

 $handler  =  static::create($type);

 return  $filter($handler);

 }  catch  (\Exception $e)  {

 return  false;

 }

 }

 );

    }

 /**

     * 获取需要库存管理的类型

     */

 public  static  function  getInventoryRequiredTypes(): array

    {

 return  static::getTypesBy(fn($handler) => $handler->requiresInventory());

    }

 /**

     * 获取需要物流的类型

     */

 public  static  function  getShippingRequiredTypes(): array

    {

 return  static::getTypesBy(fn($handler) => $handler->requiresShipping());

    }

}

```

#### 扩展示例

```php

namespace App\Ecommerce\ProductTypes;

use RedJasmine\Ecommerce\Domain\Contracts\ProductTypeInterface;

/**

 * 酒店商品类型

 */

class HotelProductType implements ProductTypeInterface

{

 public  function  type(): string

    {

 return  'hotel';

    }

 public  function  label(): string

    {

 return  '酒店';

    }

 public  function  icon(): ?string

    {

 return  'emoji-hotel';

    }

 public  function  getFulfillmentMethods(): array

    {

 return [

 'instore',  // 到店入住

 'none', // 无需配送

        ];

    }

 public  function  getDefaultShippingType(): string

    {

 return  'instore';

    }

 public  function  requiresTimeBooking(): bool

    {

 return  true;  // 酒店需要预订入住和退房时间

    }

 public  function  getExtensionFields(): array

    {

 return [

 'check_in_time' => 'datetime',

 'check_out_time' => 'datetime',

 'room_type' => 'string',

 'bed_type' => 'string',

 'breakfast_included' => 'boolean',

        ];

    }

 public  function  validateProductData(array  $data): void

    {

 if (empty($data['room_type'])) {

 throw  new  \InvalidArgumentException('房型不能为空');

        }

    }

}

// 注册自定义商品类型

ProductTypeManager::register('hotel', HotelProductType::class);

```

---

### 1.2 发货类型扩展 (ShippingTypeInterface)

#### 业务场景

不同的发货方式有不同的履约流程：

- 物流快递需要物流单号跟踪

- 同城配送需要配送员信息

- 卡密发货需要卡密内容管理

- 上门服务需要服务时间和地址

#### 内置类型

| 类型标识 | 名称 | 说明 |

|---------|------|-----|

|  `logistics`  | 物流快递 | 需要物流单号跟踪 |

|  `delivery`  | 同城配送 | 需要配送员信息 |

|  `instore`  | 到店自取 | 无需物流 |

|  `dummy`  | 虚拟发货 | 自动完成 |

|  `digital`  | 数字卡密 | 需要卡密内容 |

|  `coupons`  | 卡券 | 优惠券发放 |

|  `visit`  | 上门服务 | 需要服务时间 |

|  `none`  | 无需发货 | 跳过发货流程 |

#### 接口定义

```php

namespace RedJasmine\Ecommerce\Domain\Contracts;

/**

 * 发货类型处理器接口

 */

interface ShippingTypeHandlerInterface

{

 /**

     * 获取发货类型标识

     */

 public  function  type(): string;

 /**

     * 获取发货类型标签

     */

 public  function  label(): string;

 /**

     * 获取发货类型图标

     */

 public  function  icon(): ?string;

 /**

     * 是否需要收货地址

     */

 public  function  requiresAddress(): bool;

 /**

     * 是否需要物流单号

     */

 public  function  requiresTrackingNumber(): bool;

 /**

     * 是否需要计算运费

     */

 public  function  requiresFreight(): bool;

 /**

     * 是否支持拆单发货

     */

 public  function  supportsSplitShipping(): bool;

 /**

     * 获取发货所需的扩展字段

* @return  array

     */

 public  function  getShippingFields(): array;

 /**

     * 验证发货数据

* @param  array $data

* @throws  \InvalidArgumentException

     */

 public  function  validateShippingData(array  $data): void;

 /**

     * 执行发货

* @param $order 订单对象

* @param  array $shippingData 发货数据

* @return  mixed 发货结果

     */

 public  function  ship($order, array  $shippingData);

 /**

     * 发货前的钩子

     */

 public  function  beforeShipping($order, array  $shippingData): void;

 /**

     * 发货后的钩子

     */

 public  function  afterShipping($order, $shippingResult): void;

 /**

     * 查询物流信息（如果支持）

     */

 public  function  trackShipping(string  $trackingNumber): ?array;

}

```

#### 管理器设计

```php

namespace RedJasmine\Ecommerce\Domain\Services;

use RedJasmine\Support\Foundation\Manager\ServiceManager;

class ShippingTypeManager extends ServiceManager

{

 protected  const  PROVIDERS = [

 'logistics' => LogisticsShippingHandler::class,

 'delivery' => DeliveryShippingHandler::class,

 'digital' => DigitalShippingHandler::class,

 'dummy' => DummyShippingHandler::class,

 'visit' => VisitShippingHandler::class,

 'instore' => InstoreShippingHandler::class,

    ];

 public  static  function  register(string  $type, string|Closure $handler): void;

 public  function  create(string  $type): ShippingTypeHandlerInterface;

}

```

#### 扩展示例

```php

namespace App\Ecommerce\Shipping;

/**

 * 自提点发货处理器

 */

class PickupPointShippingHandler implements ShippingTypeHandlerInterface

{

 public  function  type(): string

    {

 return  'pickup';

    }

 public  function  label(): string

    {

 return  '自提点取货';

    }

 public  function  requiresAddress(): bool

    {

 return  false;  // 不需要收货地址，使用自提点地址

    }

 public  function  getShippingFields(): array

    {

 return [

 'pickup_point_id' => 'required|integer',

 'pickup_code' => 'required|string',

 'pickup_person_name' => 'required|string',

 'pickup_person_phone' => 'required|string',

        ];

    }

 public  function  ship($order, array  $shippingData)

    {

 // 生成取货码

 $pickupCode = $this->generatePickupCode();

 // 通知用户取货

 $this->notifyCustomer($order, $pickupCode);

 return [

 'pickup_code' => $pickupCode,

 'pickup_point' => $shippingData['pickup_point_id'],

        ];

    }

}

// 注册自定义发货类型

ShippingTypeManager::register('pickup', PickupPointShippingHandler::class);

```

---

### 1.3 价格计算策略扩展 (PriceCalculatorInterface)

#### 业务场景

不同的价格计算策略：

- 阶梯价格（购买数量越多价格越低）

- 会员价格（不同会员等级不同价格）

- 市场价格（不同市场不同价格）

- 动态定价（根据供需关系动态调整）

#### 接口定义

```php

namespace RedJasmine\Ecommerce\Domain\Contracts;

use RedJasmine\Ecommerce\Domain\Data\Product\ProductPurchaseFactor;

use RedJasmine\Ecommerce\Domain\Data\Product\ProductAmountInfo;

/**

 * 价格计算器接口

 */

interface PriceCalculatorInterface

{

 /**

     * 计算商品价格

     *

* @param  ProductPurchaseFactor $factor 购买因子（商品ID、数量、市场、用户等级等）

* @return  ProductAmountInfo 价格信息

     */

 public  function  calculate(ProductPurchaseFactor $factor): ProductAmountInfo;

 /**

     * 批量计算价格

     *

* @param  array<ProductPurchaseFactor> $factors

* @return  array<ProductAmountInfo>

     */

 public  function  batchCalculate(array  $factors): array;

 /**

     * 获取价格明细

     */

 public  function  getPriceDetails(ProductPurchaseFactor $factor): array;

 /**

     * 验证价格是否可用

     */

 public  function  validatePrice(ProductPurchaseFactor $factor): bool;

}

```

#### 管理器设计

```php

namespace RedJasmine\Product\Domain\Services;

use RedJasmine\Support\Foundation\Manager\ServiceManager;

class PriceCalculatorManager extends ServiceManager

{

 protected  const  PROVIDERS = [

 'default' => DefaultPriceCalculator::class,

 'ladder' => LadderPriceCalculator::class,

 'member' => MemberPriceCalculator::class,

 'dynamic' => DynamicPriceCalculator::class,

    ];

 public  static  function  register(string  $type, string|Closure $calculator): void;

 public  function  create(string  $type): PriceCalculatorInterface;

}

```

---

### 1.4 库存策略扩展 (InventoryStrategyInterface)

#### 业务场景

不同的库存管理策略：

- 单仓库库存

- 多仓库库存分配

- 预售库存管理

- 虚拟库存（无限库存）

#### 接口定义

```php

namespace RedJasmine\Ecommerce\Domain\Contracts;

/**

 * 库存策略接口

 */

interface InventoryStrategyInterface

{

 /**

     * 检查库存是否充足

     */

 public  function  checkStock(int  $productId, int  $skuId, int  $quantity, array  $context = []): bool;

 /**

     * 锁定库存

     */

 public  function  lockStock(int  $productId, int  $skuId, int  $quantity, string  $orderNo): bool;

 /**

     * 扣减库存

     */

 public  function  deductStock(int  $productId, int  $skuId, int  $quantity, string  $orderNo): bool;

 /**

     * 释放库存

     */

 public  function  releaseStock(int  $productId, int  $skuId, int  $quantity, string  $orderNo): bool;

 /**

     * 恢复库存

     */

 public  function  restoreStock(int  $productId, int  $skuId, int  $quantity, string  $orderNo): bool;

 /**

     * 获取可用库存

     */

 public  function  getAvailableStock(int  $productId, int  $skuId, array  $context = []): int;

 /**

     * 选择仓库（多仓库场景）

     */

 public  function  selectWarehouse(int  $productId, int  $skuId, int  $quantity, array  $context = []): ?int;

}

```

---

### 1.5 运费计算扩展 (FreightCalculatorInterface)

#### 业务场景

不同的运费计算方式：

- 按重量计费

- 按件数计费

- 按距离计费

- 包邮策略

#### 接口定义

```php

namespace RedJasmine\Ecommerce\Domain\Contracts;

use RedJasmine\Money\Data\Money;

/**

 * 运费计算器接口

 */

interface FreightCalculatorInterface

{

 /**

     * 计算运费

     *

* @param  array $products 商品列表

* @param  array $address 收货地址

* @param  array $context 上下文信息

* @return  Money 运费金额

     */

 public  function  calculate(array  $products, array  $address, array  $context = []): Money;

 /**

     * 是否支持配送到指定地址

     */

 public  function  canDeliver(array  $address): bool;

 /**

     * 获取预计配送时间

     */

 public  function  getEstimatedDeliveryTime(array  $address): ?string;

 /**

     * 获取运费明细

     */

 public  function  getFreightDetails(array  $products, array  $address): array;

}

```

---

## 二、订单领域扩展点

### 2.1 订单类型扩展 (OrderTypeInterface)

#### 业务场景

不同类型的订单有不同的业务流程：

- 标准订单：正常购买流程

- 拼团订单：需要成团逻辑

- 预售订单：需要尾款支付

- 换货订单：售后流程

- 租赁订单：需要归还流程

#### 接口定义（已存在，需要完善）

```php

namespace RedJasmine\Order\Domain\Types;

use RedJasmine\Order\Domain\Models\Order;

interface OrderTypeInterface

{

 /**

     * 获取订单类型标识

     */

 public  static  function  type(): string;

 /**

     * 获取订单类型标签

     */

 public  static  function  label(): string;

 /**

     * 获取订单类型图标

     */

 public  static  function  icon(): ?string;

 /**

     * 订单金额计算

     */

 public  function  calculateAmount(Order $order): void;

 /**

     * 订单创建前的处理

     */

 public  function  creating(Order $order): void;

 /**

     * 订单创建后的处理

     */

 public  function  created(Order $order): void;

 /**

     * 订单支付前的处理

     */

 public  function  paying(Order $order): void;

 /**

     * 订单支付成功的处理

     */

 public  function  paid(Order $order): void;

 /**

     * 订单接单的处理

     */

 public  function  accept(Order $order): void;

 /**

     * 订单拒绝的处理

     */

 public  function  reject(Order $order): void;

 /**

     * 订单发货中的处理

     */

 public  function  shipping(Order $order): void;

 /**

     * 订单已发货的处理

     */

 public  function  shipped(Order $order): void;

 /**

     * 订单确认收货的处理

     */

 public  function  confirmed(Order $order): void;

 /**

     * 订单完成的处理

     */

 public  function  finished(Order $order): void;

 /**

     * 订单取消的处理

     */

 public  function  cancelled(Order $order): void;

 /**

     * 订单关闭的处理

     */

 public  function  closed(Order $order): void;

 /**

     * 获取订单允许的操作

     */

 public  function  getAllowedActions(Order $order): array;

 /**

     * 验证订单数据

     */

 public  function  validateOrderData(array  $data): void;

 /**

     * 获取订单扩展字段

     */

 public  function  getExtensionFields(): array;

}

```

#### 扩展示例

```php

namespace App\Order\Types;

/**

 * 租赁订单类型

 */

class RentalOrderType implements OrderTypeInterface

{

 public  static  function  type(): string

    {

 return  'rental';

    }

 public  static  function  label(): string

    {

 return  '租赁订单';

    }

 public  function  getExtensionFields(): array

    {

 return [

 'rental_start_time' => 'datetime',

 'rental_end_time' => 'datetime',

 'rental_days' => 'integer',

 'deposit_amount' => 'decimal',

 'daily_rent' => 'decimal',

        ];

    }

 public  function  calculateAmount(Order $order): void

    {

 // 租赁订单金额 = 押金 + 租金

 $rentalDays = $order->extension->rental_days;

 $dailyRent = $order->extension->daily_rent;

 $deposit = $order->extension->deposit_amount;

 $order->product_amount = $dailyRent * $rentalDays;

 $order->total_amount = $order->product_amount + $deposit;

 $order->payable_amount = $order->total_amount;

    }

 public  function  finished(Order $order): void

    {

 // 订单完成后退还押金

 if ($order->extension->deposit_amount > 0) {

 $this->refundDeposit($order);

        }

    }

 protected  function  refundDeposit(Order $order): void

    {

 // 退还押金逻辑

    }

}

// 注册订单类型

OrderTypeManage::register('rental', RentalOrderType::class);

```

---

### 2.2 支付方式扩展 (PaymentMethodInterface)

#### 业务场景

集成不同的支付渠道：

- 支付宝

- 微信支付

- 银联支付

- 数字货币支付

- 第三方支付平台

#### 接口定义

```php

namespace RedJasmine\Ecommerce\Domain\Contracts;

use RedJasmine\Ecommerce\Domain\Data\Payment\PaymentTradeData;

use RedJasmine\Ecommerce\Domain\Data\Payment\PaymentTradeResult;

/**

 * 支付方式接口

 */

interface PaymentMethodInterface

{

 /**

     * 获取支付方式标识

     */

 public  function  getMethod(): string;

 /**

     * 获取支付方式名称

     */

 public  function  getName(): string;

 /**

     * 获取支付方式图标

     */

 public  function  getIcon(): ?string;

 /**

     * 是否启用

     */

 public  function  isEnabled(): bool;

 /**

     * 获取支持的支付类型

* @return  array ['online', 'offline', etc.]

     */

 public  function  getSupportedPayTypes(): array;

 /**

     * 创建支付订单

     *

* @param  PaymentTradeData $tradeData 支付交易数据

* @return  PaymentTradeResult 支付结果（包含支付参数）

     */

 public  function  createPayment(PaymentTradeData $tradeData): PaymentTradeResult;

 /**

     * 查询支付状态

     *

* @param  string $paymentNo 支付单号

* @return  array 支付状态信息

     */

 public  function  queryPayment(string  $paymentNo): array;

 /**

     * 关闭支付订单

     */

 public  function  closePayment(string  $paymentNo): bool;

 /**

     * 退款

     *

* @param  string $paymentNo 支付单号

* @param  float $amount 退款金额

* @param  string $reason 退款原因

* @return  array 退款结果

     */

 public  function  refund(string  $paymentNo, float  $amount, string  $reason = ''): array;

 /**

     * 查询退款状态

     */

 public  function  queryRefund(string  $refundNo): array;

 /**

     * 处理支付回调

     *

* @param  array $callbackData 回调数据

* @return  array 处理结果

     */

 public  function  handleCallback(array  $callbackData): array;

 /**

     * 验证回调签名

     */

 public  function  verifyCallback(array  $callbackData): bool;

 /**

     * 获取支付配置要求

     */

 public  function  getConfigRequirements(): array;

}

```

#### 管理器设计

```php

namespace RedJasmine\Ecommerce\Domain\Services;

use RedJasmine\Support\Foundation\Manager\ServiceManager;

class PaymentMethodManager extends ServiceManager

{

 protected  const  PROVIDERS = [

 'alipay' => AlipayPaymentMethod::class,

 'wechat' => WechatPaymentMethod::class,

 'union' => UnionPaymentMethod::class,

    ];

 public  static  function  register(string  $method, string|Closure $handler): void;

 public  function  create(string  $method): PaymentMethodInterface;

 /**

     * 获取所有启用的支付方式

     */

 public  function  getEnabledMethods(): array;

}

```

#### 扩展示例

```php

namespace App\Payment\Methods;

/**

 * Stripe 支付方式

 */

class StripePaymentMethod implements PaymentMethodInterface

{

 public  function  getMethod(): string

    {

 return  'stripe';

    }

 public  function  getName(): string

    {

 return  'Stripe';

    }

 public  function  createPayment(PaymentTradeData $tradeData): PaymentTradeResult

    {

 // 调用 Stripe API 创建支付

 $stripe = new  \Stripe\StripeClient(config('payment.stripe.secret_key'));

 $paymentIntent = $stripe->paymentIntents->create([

 'amount' => $tradeData->amount * 100, // Stripe 使用分为单位

 'currency' => strtolower($tradeData->currency),

 'metadata' => [

 'order_no' => $tradeData->orderNo,

            ],

        ]);

 return PaymentTradeResult::from([

 'payment_id' => $paymentIntent->id,

 'payment_params' => [

 'client_secret' => $paymentIntent->client_secret,

            ],

        ]);

    }

 public  function  handleCallback(array  $callbackData): array

    {

 // 处理 Stripe webhook

 $event = \Stripe\Webhook::constructEvent(

 $callbackData['payload'],

 $callbackData['signature'],

 config('payment.stripe.webhook_secret')

        );

 if ($event->type === 'payment_intent.succeeded') {

 return [

 'status' => 'success',

 'payment_id' => $event->data->object->id,

 'amount' => $event->data->object->amount / 100,

            ];

        }

 return ['status' => 'pending'];

    }

}

// 注册支付方式

PaymentMethodManager::register('stripe', StripePaymentMethod::class);

```

---

### 2.3 订单金额计算策略 (OrderAmountCalculatorInterface)

#### 业务场景

复杂的订单金额计算逻辑：

- 商品优惠

- 订单优惠

- 运费计算

- 税费计算

- 积分抵扣

#### 接口定义

```php

namespace RedJasmine\Ecommerce\Domain\Contracts;

use RedJasmine\Order\Domain\Models\Order;

/**

 * 订单金额计算器接口

 */

interface OrderAmountCalculatorInterface

{

 /**

     * 计算订单金额

     */

 public  function  calculate(Order $order): void;

 /**

     * 计算商品金额

     */

 public  function  calculateProductAmount(Order $order): void;

 /**

     * 计算优惠金额

     */

 public  function  calculateDiscountAmount(Order $order): void;

 /**

     * 计算运费

     */

 public  function  calculateFreightAmount(Order $order): void;

 /**

     * 计算税费

     */

 public  function  calculateTaxAmount(Order $order): void;

 /**

     * 计算应付金额

     */

 public  function  calculatePayableAmount(Order $order): void;

 /**

     * 获取金额明细

     */

 public  function  getAmountDetails(Order $order): array;

}

```

---

## 三、促销活动扩展点

### 3.1 活动类型扩展 (ActivityTypeHandlerInterface)

#### 业务场景（已实现，参考文档）

- 秒杀活动

- 拼团活动

- 满减活动

- 砍价活动

- 优惠券活动

- 积分兑换活动

当前实现已经很完善，参考 `packages/promotion` 包的实现。

#### 扩展示例

```php

namespace App\Promotion\Handlers;

use RedJasmine\Promotion\Domain\Services\AbstractActivityTypeHandler;

/**

 * 积分兑换活动处理器

 */

class PointsExchangeActivityHandler extends AbstractActivityTypeHandler

{

 public  function  getActivityType(): string

    {

 return  'points_exchange';

    }

 public  function  getExtensionFields(): array

    {

 return [

 'points_required' => 'integer',  // 所需积分

 'exchange_limit' => 'integer', // 兑换限制

        ];

    }

 protected  function  validateSpecificData(ActivityData $data): void

    {

 if (empty($data->extension['points_required'])) {

 throw  new  \InvalidArgumentException('所需积分不能为空');

        }

    }

 protected  function  calculateActivityPrice(

Activity $activity,

ActivityProduct $activityProduct,

 int  $quantity,

 array  $context

): float {

 // 积分兑换价格为 0

 return  0.00;

    }

 protected  function  validateSpecificParticipation(

Activity $activity,

UserInterface $user,

 array  $participationData

): void {

 // 检查用户积分是否足够

 $requiredPoints = $activity->extension['points_required'];

 $userPoints = $this->getUserPoints($user);

 if ($userPoints < $requiredPoints) {

 throw  new  \RuntimeException('积分不足');

        }

    }

 protected  function  executeParticipationLogic(

Activity $activity,

ActivityOrder $activityOrder,

 array  $participationData

): void {

 // 扣减用户积分

 $this->deductUserPoints(

 $activityOrder->user,

 $activity->extension['points_required']

        );

    }

}

// 注册活动类型

ActivityTypeHandlerFactory::register('points_exchange', PointsExchangeActivityHandler::class);

```

---

### 3.2 优惠券类型扩展 (CouponTypeInterface)

#### 业务场景

不同类型的优惠券：

- 满减券

- 折扣券

- 包邮券

- 兑换券

- 现金券

#### 接口定义

```php

namespace RedJasmine\Ecommerce\Domain\Contracts;

/**

 * 优惠券类型接口

 */

interface CouponTypeInterface

{

 /**

     * 获取优惠券类型

     */

 public  function  getType(): string;

 /**

     * 获取优惠券类型名称

     */

 public  function  getName(): string;

 /**

     * 验证优惠券是否可用

     */

 public  function  validate($coupon, array  $orderData): bool;

 /**

     * 计算优惠金额

     */

 public  function  calculateDiscount($coupon, array  $orderData): float;

 /**

     * 获取优惠明细

     */

 public  function  getDiscountDetails($coupon, array  $orderData): array;

 /**

     * 获取使用条件描述

     */

 public  function  getConditionDescription($coupon): string;

}

```

---

## 四、跨领域扩展点

### 4.1 市场扩展 (MarketProviderInterface)

#### 业务场景（已实现）

支持多市场/多站点：

- 不同国家/地区

- 不同语言

- 不同货币

- 不同价格体系

参考 `packages/product/src/Domain/Contracts/MarketProviderInterface.php`

---

### 4.2 仓库扩展 (WarehouseProviderInterface)

#### 业务场景（已实现）

支持多仓库管理：

- 不同地区仓库

- 仓库库存分配

- 就近发货策略

参考 `packages/product/src/Domain/Contracts/WarehouseProviderInterface.php`

---

### 4.3 税务扩展 (TaxProviderInterface)

#### 业务场景（已实现）

支持不同的税务计算：

- 不同地区税率

- 不同商品税类

- 税额计算

参考 `packages/product/src/Domain/Contracts/TaxProviderInterface.php`

---

### 4.4 物流服务商扩展 (LogisticsProviderInterface)

#### 业务场景

集成不同的物流服务商：

- 顺丰快递

- 京东物流

- 圆通快递

- 国际物流

#### 接口定义

```php

namespace RedJasmine\Ecommerce\Domain\Contracts;

/**

 * 物流服务商接口

 */

interface LogisticsProviderInterface

{

 /**

     * 获取物流商代码

     */

 public  function  getCode(): string;

 /**

     * 获取物流商名称

     */

 public  function  getName(): string;

 /**

     * 创建物流订单

     */

 public  function  createOrder(array  $orderData): array;

 /**

     * 查询物流轨迹

     */

 public  function  track(string  $trackingNumber): array;

 /**

     * 计算运费

     */

 public  function  calculateFreight(array  $params): float;

 /**

     * 取消物流订单

     */

 public  function  cancelOrder(string  $trackingNumber): bool;

}

```

---

### 4.5 消息通知扩展 (NotificationChannelInterface)

#### 业务场景

不同的消息通知渠道：

- 短信通知

- 邮件通知

- 站内信

- 推送通知

- 微信模板消息

#### 接口定义

```php

namespace RedJasmine\Ecommerce\Domain\Contracts;

/**

 * 通知渠道接口

 */

interface NotificationChannelInterface

{

 /**

     * 获取渠道名称

     */

 public  function  getName(): string;

 /**

     * 发送通知

     */

 public  function  send($recipient, string  $template, array  $data): bool;

 /**

     * 批量发送

     */

 public  function  sendBatch(array  $recipients, string  $template, array  $data): array;

 /**

     * 验证接收者信息

     */

 public  function  validateRecipient($recipient): bool;

}

```

---

### 4.6 售后类型扩展 (AfterSaleTypeInterface)

#### 业务场景

不同类型的售后服务：

- 仅退款

- 退货退款

- 换货

- 维修

- 补发

#### 接口定义

```php

namespace RedJasmine\Ecommerce\Domain\Contracts;

/**

 * 售后类型接口

 */

interface AfterSaleTypeInterface

{

 /**

     * 获取售后类型

     */

 public  function  getType(): string;

 /**

     * 获取售后类型名称

     */

 public  function  getName(): string;

 /**

     * 验证售后申请

     */

 public  function  validate($order, array  $afterSaleData): bool;

 /**

     * 处理售后申请

     */

 public  function  process($order, $afterSale): void;

 /**

     * 同意售后

     */

 public  function  approve($afterSale): void;

 /**

     * 拒绝售后

     */

 public  function  reject($afterSale, string  $reason): void;

 /**

     * 完成售后

     */

 public  function  complete($afterSale): void;

 /**

     * 获取售后流程步骤

     */

 public  function  getFlowSteps($afterSale): array;

}

```

---

## 五、扩展点注册和使用

### 5.1 服务提供者中注册

```php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class EcommerceExtensionServiceProvider extends ServiceProvider

{

 public  function  register(): void

    {

 // 注册商品类型

        ProductTypeManager::register('hotel', HotelProductType::class);

 // 注册发货类型

        ShippingTypeManager::register('pickup', PickupPointShippingHandler::class);

 // 注册订单类型

        OrderTypeManage::register('rental', RentalOrderType::class);

 // 注册支付方式

        PaymentMethodManager::register('stripe', StripePaymentMethod::class);

 // 注册活动类型

        ActivityTypeHandlerFactory::register('points_exchange', PointsExchangeActivityHandler::class);

    }

 public  function  boot(): void

    {

 // 注册钩子

        Hook::register('product.creating', function ($product) {

 // 商品创建前的扩展逻辑

        });

    }

}

```

### 5.2 配置文件中注册

```php

// config/ecommerce.php

return [

 'product_types' => [

 'hotel' => App\Ecommerce\ProductTypes\HotelProductType::class,

    ],

 'fulfillment_methods' => [

 'pickup' => App\Ecommerce\Shipping\PickupPointShippingHandler::class,

    ],

 'payment_methods' => [

 'stripe' => App\Payment\Methods\StripePaymentMethod::class,

    ],

];

```

### 5.3 运行时动态注册

```php

// 在应用启动时

ProductTypeManager::register('custom_type', function($config) {

 return  new CustomProductType($config);

});

```

---

## 六、扩展点开发最佳实践

### 6.1 接口设计原则

1. **单一职责**: 每个接口只负责一个具体的扩展点

2. **开闭原则**: 对扩展开放，对修改关闭

3. **里氏替换**: 子类可以替换父类

4. **依赖倒置**: 依赖抽象而不是具体实现

5. **接口隔离**: 接口应该小而精

### 6.2 抽象基类设计

为每个扩展点提供抽象基类：

- 实现通用逻辑

- 定义模板方法

- 提供工具方法

- 减少重复代码

### 6.3 钩子机制使用

在关键节点提供钩子：

```php

public  function  createProduct($data)

{

 $product = $this->hook('creating', $data, function() use ($data) {

 // 创建商品的核心逻辑

 return  $this->doCreateProduct($data);

    });

 $this->hook('created', $product, function() use ($product) {

 // 商品创建后的处理

    });

 return  $product;

}

```

### 6.4 事件驱动

使用领域事件解耦：

```php

// 发布事件

ProductCreatedEvent::dispatch($product);

// 监听事件

Event::listen(ProductCreatedEvent::class, function($event) {

 // 处理商品创建后的业务逻辑

});

```

### 6.5 配置管理

所有扩展应支持配置：

```php

public  function  __construct(array  $config = [])

{

 $this->config = array_merge($this->getDefaultConfig(),  $config);

}

protected  function  getDefaultConfig(): array

{

 return [

 'enabled' => true,

 'timeout' => 30,

    ];

}

```

### 6.6 异常处理

定义清晰的异常层次：

```php

class EcommerceException extends Exception {}

class ProductTypeException extends EcommerceException {}

class ShippingTypeException extends EcommerceException {}

```

### 6.7 测试

为每个扩展点编写测试：

```php

class HotelProductTypeTest extends TestCase

{

 public  function  test_it_requires_time_booking()

    {

 $type = new HotelProductType();

 $this->assertTrue($type->requiresTimeBooking());

    }

 public  function  test_it_validates_product_data()

    {

 $type = new HotelProductType();

 $this->expectException(\InvalidArgumentException::class);

 $type->validateProductData([]);

    }

}

```

---

## 七、核心包清单

### 7.1 ecommerce 包应提供的接口

- `ProductTypeInterface` - 商品类型接口

- `ShippingTypeHandlerInterface` - 发货类型接口

- `PriceCalculatorInterface` - 价格计算接口

- `InventoryStrategyInterface` - 库存策略接口

- `FreightCalculatorInterface` - 运费计算接口

- `PaymentMethodInterface` - 支付方式接口

- `LogisticsProviderInterface` - 物流服务商接口

- `NotificationChannelInterface` - 通知渠道接口

- `AfterSaleTypeInterface` - 售后类型接口

- `CouponTypeInterface` - 优惠券类型接口

- `OrderAmountCalculatorInterface` - 订单金额计算接口

### 7.2 ecommerce 包应提供的管理器

- `ProductTypeManager` - 商品类型管理器

- `ShippingTypeManager` - 发货类型管理器

- `PriceCalculatorManager` - 价格计算管理器

- `PaymentMethodManager` - 支付方式管理器

- `LogisticsProviderManager` - 物流服务商管理器

- `CouponTypeManager` - 优惠券类型管理器

### 7.3 设计原则：纯接口驱动

**重要：不使用枚举定义类型，完全通过接口驱动！**

设计原则：

- **无枚举限制**：不定义类型枚举，避免封闭性

- **接口契约**：通过接口定义类型的行为和属性

- **管理器统一**：通过管理器注册和创建所有类型

- **字符串标识**：所有类型使用字符串作为唯一标识

各扩展点需要提供的组件：

- `ProductTypeInterface` + `ProductTypeManager`

- `ShippingTypeHandlerInterface` + `ShippingTypeManager`

- `PaymentMethodInterface` + `PaymentMethodManager`

- `OrderTypeInterface` + `OrderTypeManager`

- `ActivityTypeHandlerInterface` + `ActivityTypeHandlerFactory`

- `CouponTypeInterface` + `CouponTypeManager`

- `AfterSaleTypeInterface` + `AfterSaleTypeManager`

**使用模式**：

```php

// 1. 存储：使用字符串

$product->type = 'physical';  // 直接字符串

$product->type = 'hotel'; // 扩展类型也是字符串

// 2. 标签：通过管理器获取

$label = ProductTypeManager::create($product->type)->label();

// 3. 验证：使用管理器

'type' => ['required', Rule::in(ProductTypeManager::getAllTypes())],

// 4. 业务逻辑：统一使用接口

$handler = ProductTypeManager::create($product->type);

$handler->validateProductData($data);

$fields = $handler->getExtensionFields();

```

---

## 八、迁移计划

### 阶段一：接口定义（已部分完成）

-  [x] ProductTypeInterface（需完善）

-  [x] FreightTemplateServiceInterface

-  [x] MarketProviderInterface

-  [x] WarehouseProviderInterface

-  [x] TaxProviderInterface

-  [x] ActivityTypeHandlerInterface（promotion包）

-  [x] OrderTypeInterface（需完善）

### 阶段二：新增核心接口

- [ ] ShippingTypeHandlerInterface

- [ ] PriceCalculatorInterface

- [ ] InventoryStrategyInterface

- [ ] PaymentMethodInterface

- [ ] LogisticsProviderInterface

- [ ] CouponTypeInterface

- [ ] AfterSaleTypeInterface

- [ ] OrderAmountCalculatorInterface

- [ ] NotificationChannelInterface

### 阶段三：管理器实现

- [ ] 为每个扩展点实现对应的管理器

- [ ] 提供默认实现

- [ ] 编写使用文档

### 阶段四：示例和测试

- [ ] 为每个扩展点提供完整示例

- [ ] 编写单元测试

- [ ] 编写集成测试

- [ ] 编写文档和教程

---

## 九、使用示例

### 示例1：扩展新的商品类型（会员卡）

```php

// 步骤1：实现商品类型接口

// 文件：app/ProductTypes/MembershipProductType.php

namespace App\ProductTypes;

use RedJasmine\Ecommerce\Domain\Contracts\ProductTypeInterface;

class MembershipProductType implements ProductTypeInterface

{

 public  function  type(): string

    {

 return  'membership';  // 使用字符串标识

    }

 public  function  label(): string

    {

 return  '会员卡';

    }

 public  function  icon(): ?string

    {

 return  'emoji-card';

    }

 public  function  tips(): ?string

    {

 return  '会员卡商品，购买后自动开通会员';

    }

 public  function  requiresInventory(): bool

    {

 return  false;  // 会员卡不需要库存管理

    }

 public  function  requiresShipping(): bool

    {

 return  false;  // 会员卡不需要物流

    }

 public  function  getFulfillmentMethods(): array

    {

 return ['none'];  // 无需发货

    }

 public  function  getDefaultShippingType(): string

    {

 return  'none';

    }

 public  function  requiresDeliveryAddress(): bool

    {

 return  false;

    }

 public  function  requiresTimeBooking(): bool

    {

 return  false;

    }

 public  function  requiresRealName(): bool

    {

 return  false;

    }

 public  function  getExtensionFields(): array

    {

 return [

 'validity_days' => 'integer', // 有效期天数

 'member_level' => 'string', // 会员等级

 'auto_renewal' => 'boolean',    // 是否自动续费

        ];

    }

 public  function  validateProductData(array  $data): void

    {

 if (empty($data['validity_days']) ||  $data['validity_days'] <= 0) {

 throw  new  \InvalidArgumentException('会员卡有效期必须大于0天');

        }

    }

 public  function  onProductCreating($product): void {}

 public  function  onProductCreated($product): void {}

 public  function  onProductPublishing($product): void {}

 public  function  getPriceCalculator(): ?string

    {

 return  null;

    }

 public  function  getInventoryCalculator(): ?string

    {

 return  null;

    }

}

// 步骤2：注册到管理器

// 文件：app/Providers/EcommerceExtensionServiceProvider.php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

use RedJasmine\Ecommerce\Domain\Services\ProductTypeManager;

use App\ProductTypes\MembershipProductType;

class EcommerceExtensionServiceProvider extends ServiceProvider

{

 public  function  register(): void

    {

 // 使用字符串标识注册

        ProductTypeManager::register('membership', MembershipProductType::class);

    }

}

// 步骤3：使用

// 3.1 存储：使用字符串

$product = new Product();

$product->type = 'membership';

// 3.2 验证：使用管理器

$request->validate([

 'type' => ['required', Rule::in(ProductTypeManager::getAllTypes())],

]);

// 3.3 业务逻辑：使用接口

$handler = ProductTypeManager::create($product->type);

$handler->validateProductData($data);

if ($handler->requiresInventory()) {

 // 处理库存

}

// 3.4 显示标签

$label = ProductTypeManager::create($product->type)->label();  // "会员卡"

$icon = ProductTypeManager::create($product->type)->icon();    // "emoji-card"

```

**核心要点**：

- ✅ **接口实现**：定义类型的所有属性和业务逻辑

- ✅ **字符串标识**：使用字符串作为类型唯一标识

- ✅ **管理器注册**：将类型实现注册到管理器

- ✅ **统一使用**：存储、验证、显示都通过管理器

- ✅ **完全平等**：内置类型和扩展类型没有区别

### 示例2：扩展新的支付方式（加密货币）

```php

// 1. 创建支付方式实现

class CryptoPaymentMethod implements PaymentMethodInterface

{

 public  function  getMethod(): string { return  'crypto'; }

 public  function  createPayment(PaymentTradeData $tradeData): PaymentTradeResult

    {

 // 调用加密货币支付网关

 $gateway = new CryptoGateway();

 $result = $gateway->createPayment([

 'amount' => $tradeData->amount,

 'currency' => 'USDT',

        ]);

 return PaymentTradeResult::from([

 'payment_id' => $result['payment_id'],

 'payment_params' => $result,

        ]);

    }

 // ... 其他方法实现

}

// 2. 注册支付方式

PaymentMethodManager::register('crypto', CryptoPaymentMethod::class);

// 3. 使用

$paymentMethod = PaymentMethodManager::create('crypto');

$result = $paymentMethod->createPayment($tradeData);

```

### 示例3：扩展新的活动类型（抽奖）

```php

// 1. 创建活动处理器

class LotteryActivityHandler extends AbstractActivityTypeHandler

{

 public  function  getActivityType(): string

    {

 return  'lottery';

    }

 protected  function  calculateActivityPrice(

Activity $activity,

ActivityProduct $activityProduct,

 int  $quantity,

 array  $context

): float {

 // 抽奖券价格

 return  $activity->extension['ticket_price'] ?? 0;

    }

 protected  function  executeParticipationLogic(

Activity $activity,

ActivityOrder $activityOrder,

 array  $participationData

): void {

 // 执行抽奖逻辑

 $prize = $this->drawLottery($activity);

 $activityOrder->prize = $prize;

    }

 // ... 其他方法实现

}

// 2. 注册活动类型

ActivityTypeHandlerFactory::register('lottery', LotteryActivityHandler::class);

// 3. 使用

$handler = ActivityTypeHandlerFactory::make('lottery');

$result = $handler->handleParticipation($activity, $user, $data);

```

---

## 十、总结

本文档定义了 Red Jasmine 电商系统的核心扩展点，涵盖了商品、订单、促销、支付等多个领域。通过**纯接口驱动**的设计和管理器模式，开发者可以轻松扩展系统功能，而无需修改核心代码。

### 关键要点

1. **无枚举设计**：不使用枚举定义类型，避免封闭性限制

2. **纯接口驱动**：所有类型通过接口定义行为和属性

3. **字符串标识**：所有类型使用字符串作为唯一标识

4. **管理器统一**：使用管理器注册、创建、查询所有类型

5. **完全平等**：内置类型和扩展类型地位相同

6. **提供抽象基类**：减少重复代码

7. **钩子和事件机制**：提供扩展点

8. **遵循 SOLID 原则**：开闭原则、依赖倒置

### 类型系统架构：接口 + 管理器

| 维度 | 内置类型 | 扩展类型 |

|------|---------|---------|

|  **定位**  | 系统默认提供 | 第三方扩展 |

|  **定义位置**  | 核心包 | 扩展包/应用层 |

|  **存储**  | 字符串 | 字符串 |

|  **实现方式**  | 实现接口 + PROVIDERS | 实现接口 + register() |

|  **地位**  | 完全平等 | 完全平等 |

**使用流程**：

```

需要添加新的类型？

    │

    └─ 步骤1：实现接口

       │    class HotelProductType implements ProductTypeInterface

       │

       └─ 步骤2：注册到管理器

          │    ProductTypeManager::register('hotel', HotelProductType::class);

          │

          └─ 步骤3：使用

               $product->type = 'hotel';

               $handler = ProductTypeManager::create('hotel');

数据存储：

    字符串（如 'physical', 'hotel'）

表单验证：

    Rule::in(ProductTypeManager::getAllTypes())

显示标签：

    ProductTypeManager::create($value)->label()

业务逻辑：

    ProductTypeManager::create($value)->method()

```

### 架构设计图

```

┌─────────────────────────────────────────────────────────────┐

│                        应用层                                │

│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │

│  │ 表单验证      │  │ 业务逻辑      │  │ 数据展示      │      │

│  │ (使用管理器)  │  │ (使用接口)    │  │ (使用接口)    │      │

│  └──────────────┘  └──────────────┘  └──────────────┘      │

└────────────┬──────────────┬──────────────┬─────────────────┘

             │              │              │

             ▼              ▼              ▼

┌─────────────────────────────────────────────────────────────┐

│                        核心层                                │

│  ┌──────────────────────┐  ┌──────────────────────┐        │

│  │ 接口定义              │  │ 管理器                │        │

│  │ - 行为契约            │  │ - 注册管理            │        │

│  │ - 方法签名            │  │ - 实例创建            │        │

│  │ - 类型约束            │  │ - 类型查询            │        │

│  └──────────────────────┘  └──────────────────────┘        │

└────────────┬──────────────────────────────┬─────────────────┘

             │                              │

             └──────────────┬───────────────┘

                            ▼

┌─────────────────────────────────────────────────────────────┐

│                        实现层                                │

│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │

│  │ 内置实现      │  │ 扩展实现      │  │ 第三方实现    │      │

│  │ - Physical    │  │ - Hotel       │  │ - Custom      │      │

│  │ - Virtual     │  │ - Ticket      │  │ - Plugin      │      │

│  │ (完全平等)    │  │ (完全平等)    │  │ (完全平等)    │      │

│  └──────────────┘  └──────────────┘  └──────────────┘      │

└─────────────────────────────────────────────────────────────┘

```

### 设计理念总结

**纯接口驱动**：

- **接口契约**：定义类型行为和属性

- **字符串标识**：所有类型使用字符串作为标识

- **管理器统一**：统一注册、创建、查询

- **完全平等**：内置和扩展类型地位相同

**最佳实践**：

- ✅ 数据存储使用字符串

- ✅ 验证使用管理器

- ✅ 业务逻辑使用接口

- ✅ 内置类型：PROVIDERS 常量

- ✅ 扩展类型：register() 方法

### 下一步工作

1. 完善现有接口定义

2. 实现所有管理器

3. 提供内置类型默认实现

4. 编写完整的使用文档

5. 编写测试用例

6. 提供更多示例

---

## 附录A：接口驱动设计原则

### 设计定位

**不使用枚举，完全通过接口和管理器实现类型系统。**

### 核心架构

```php

// ✅ 接口定义：类型契约

interface ProductTypeInterface

{

 public  function  type(): string;

 public  function  label(): string;

 public  function  requiresInventory(): bool;

 // ...

}

// ✅ 内置类型实现：与扩展类型完全平等

class PhysicalProductType implements ProductTypeInterface

{

 public  function  type(): string { return  'physical'; }

 public  function  label(): string { return  '实物商品'; }

 // ...

}

// ✅ 扩展类型实现：与内置类型完全平等

class HotelProductType implements ProductTypeInterface

{

 public  function  type(): string { return  'hotel'; }

 public  function  label(): string { return  '酒店'; }

 // ...

}

// ✅ 管理器：统一管理所有类型

ProductTypeManager::getAllTypes(); // ['physical', 'virtual', 'hotel', 'ticket', ...]

```

### 使用管理器保证一致性

#### 1. 验证

```php
// ✅ 使用管理器验证类型是否存在
if (!ProductTypeManager::exists($type)) {
    throw new InvalidArgumentException("类型不存在: {$type}");
}

// ✅ 表单验证
'type' => ['required', Rule::in(ProductTypeManager::getAllTypes())],
```

#### 2. 数据一致性

```php
// ✅ 存储时使用字符串
$product->type = 'physical'; // 所有类型统一使用字符串
```

#### 3. IDE 支持

```php
// ✅ 使用常量类或管理器常量
class ProductTypes {
    const PHYSICAL = 'physical';
    const VIRTUAL = 'virtual';
}

// ✅ 通过管理器获取标签
ProductTypeManager::create(ProductTypes::PHYSICAL)->label();
```

#### 4. 表单验证

```php
// ✅ 使用管理器提供验证规则
'type' => ['required', Rule::in(ProductTypeManager::getAllTypes())],
// 自动包含所有已注册类型
```

#### 5. 数据库迁移

```php
// ✅ 动态生成注释
$types = ProductTypeManager::getTypeLabels();
$comment = implode(',', array_map(fn($k, $v) => "{$k}={$v}", array_keys($types), $types));
$table->string('type', 64)->comment("商品类型: {$comment}");
```

### 接口的优势

#### 1. 复杂业务逻辑

```php
// ✅ 接口实现复杂逻辑
interface ProductTypeInterface {
    public function calculatePrice(array $factors): Money;
    public function validateInventory(int $quantity): bool;
    public function beforeProductCreate($product): void;
}
```

#### 2. 依赖注入

```php
// ✅ 接口支持依赖注入
class HotelProductType implements ProductTypeInterface {
    public function __construct(
        private RoomService $roomService,
        private BookingService $bookingService
    ) {}
}
```

#### 3. 状态管理

```php
// ✅ 接口实现可以有状态
class DynamicPriceCalculator implements PriceCalculatorInterface {
    private array $cache = [];
    
    public function calculate() { 
        /* 使用缓存 */ 
    }
}
```

#### 4. 第三方扩展

```php
// ✅ 接口允许第三方扩展
// 插件可以实现接口并注册
class CustomProductType implements ProductTypeInterface { }

ProductTypeManager::register('custom', CustomProductType::class);
```

### 完整示例

```php

// 接口定义

interface ProductTypeInterface {

 public  function  type(): string;

 public  function  label(): string;

 public  function  requiresInventory(): bool;

 public  function  calculatePrice(): Money;

 public  function  validateInventory(): bool;

}

// 实现：使用字符串标识

class PhysicalProductType implements ProductTypeInterface {

 public  function  type(): string {

 return  'physical'; // 直接返回字符串

    }

 public  function  label(): string {

 return  '实物商品';

    }

 public  function  calculatePrice(): Money {

 // 实现复杂的价格计算逻辑

    }

}

// 使用：统一通过管理器

$product->type = 'physical';                          // 存储：字符串

$label = ProductTypeManager::create($product->type)->label(); // 显示：接口

$handler = ProductTypeManager::create($product->type); // 处理：接口

$price = $handler->calculatePrice(); // 逻辑：接口

```

### 使用场景映射

| 场景 | 使用组件 | 说明 |

|------|----------|------|

| 数据存储 | 字符串 | 所有类型统一使用字符串 |

| 表单验证 | 管理器 |  `ProductTypeManager::getAllTypes()`  |

| 类型判断 | 管理器 |  `ProductTypeManager::exists($type)`  |

| 显示标签 | 接口 |  `ProductTypeManager::create($type)->label()`  |

| 业务逻辑 | 接口实现 | 统一使用接口处理 |

| 扩展功能 | 接口实现 | 实现接口并注册到管理器 |

| 依赖注入 | 接口实现 | Laravel 容器自动注入 |

| 复杂计算 | 接口实现 | 在接口方法中实现 |

### 设计理念

**纯接口驱动，统一管理**：

- 🔤 **字符串**：类型唯一标识，支持自由命名

- 🔧 **接口**：定义类型行为和属性

- 📦 **管理器**：统一注册、创建、查询

---

## 附录B：扩展类型实战指南

### 实战场景：开发酒店预订插件

以开发一个酒店预订插件为例，演示如何零侵入地扩展 `hotel` 商品类型。

### 完整实现方案

**步骤1：定义类型实现类**

```php

// 文件：your-hotel-plugin/src/ProductTypes/HotelProductType.php

namespace YourCompany\HotelPlugin\ProductTypes;

use RedJasmine\Ecommerce\Domain\Contracts\ProductTypeInterface;

class HotelProductType implements ProductTypeInterface

{

 public  function  type(): string

    {

 return  'hotel';

    }

 public  function  label(): string

    {

 return  __('hotel-plugin::types.hotel'); // 使用插件自己的翻译

    }

 public  function  icon(): ?string

    {

 return  'heroicon-o-building-office';

    }

 public  function  getFulfillmentMethods(): array

    {

 return [

 'instore',  // 到店入住

 'none',

        ];

    }

 public  function  requiresTimeBooking(): bool

    {

 return  true; // 酒店需要预订时间

    }

 public  function  getExtensionFields(): array

    {

 return [

 'check_in_time' => 'datetime',

 'check_out_time' => 'datetime',

 'room_type' => 'string',

 'bed_type' => 'string',

 'breakfast_included' => 'boolean',

 'cancellation_policy' => 'text',

        ];

    }

 // ... 实现其他接口方法

}

```

**步骤2：在服务提供者中注册**

```php

// 文件：your-hotel-plugin/src/HotelPluginServiceProvider.php

namespace YourCompany\HotelPlugin;

use Illuminate\Support\ServiceProvider;

use RedJasmine\Ecommerce\Domain\Services\ProductTypeManager;

use YourCompany\HotelPlugin\ProductTypes\HotelProductType;

class HotelPluginServiceProvider extends ServiceProvider

{

 public  function  register(): void

    {

 // ✅ 注册类型到管理器

        ProductTypeManager::register('hotel', HotelProductType::class);

 // 可以注册多个类型

 // ProductTypeManager::register('apartment', ApartmentProductType::class);

 // ProductTypeManager::register('homestay', HomestayProductType::class);

    }

 public  function  boot(): void

    {

 // 注册翻译、路由等

 $this->loadTranslationsFrom(__DIR__.'/../resources/lang', 'hotel-plugin');

    }

}

```

**步骤3：数据库迁移**

```php

// 文件：your-hotel-plugin/database/migrations/xxx_create_hotel_products_table.php

Schema::create('hotel_product_extensions', function (Blueprint $table) {

 $table->unsignedBigInteger('product_id')->primary();

 $table->dateTime('check_in_time')->nullable();

 $table->dateTime('check_out_time')->nullable();

 $table->string('room_type', 50)->nullable();

 $table->string('bed_type', 50)->nullable();

 $table->boolean('breakfast_included')->default(false);

 $table->text('cancellation_policy')->nullable();

 $table->timestamps();

 $table->comment('酒店商品扩展信息');

});

```

**步骤4：使用**

```php

// 创建酒店商品

$product = new Product();

$product->type = 'hotel'; // ✅ 直接使用字符串

$product->name = '豪华海景房';

$product->extension = [

 'check_in_time' => '14:00',

 'check_out_time' => '12:00',

 'room_type' => 'deluxe',

 'breakfast_included' => true,

];

$product->save();

// 验证（自动支持扩展类型）

$request->validate([

 'type' => ['required', Rule::in(ProductTypeManager::getAllTypes())],

 // 'hotel' 会自动包含在允许的类型中

]);

// 业务逻辑

$typeHandler = ProductTypeManager::create($product->type);

if ($typeHandler->requiresTimeBooking()) {

 // 处理预订时间

}

// 显示

$label = ProductTypeManager::create($product->type)->label(); // "酒店"

```

**步骤5：测试扩展类型**

```php

// 测试：扩展类型已注册

$this->assertTrue(ProductTypeManager::exists('hotel'));

$this->assertTrue(ProductTypeManager::isExtension('hotel'));

$this->assertFalse(ProductTypeManager::isCore('hotel'));

// 测试：可以创建处理器

$handler = ProductTypeManager::create('hotel');

$this->assertInstanceOf(HotelProductType::class, $handler);

$this->assertEquals('酒店', $handler->label());

// 测试：包含在所有类型中

$allTypes = ProductTypeManager::getAllTypes();

$this->assertContains('hotel', $allTypes);

```

### 多插件共存示例

```php

// 插件A：酒店插件

ProductTypeManager::register('hotel', HotelProductType::class);

// 插件B：门票插件  

ProductTypeManager::register('ticket', TicketProductType::class);

// 插件C：课程插件

ProductTypeManager::register('course', CourseProductType::class);

// 所有类型都可以使用

ProductTypeManager::getAllTypes();

// ['physical', 'virtual', 'hotel', 'ticket', 'course', ...]

// 每个插件独立工作，互不干扰 ✅

```

### 方案优势

| 优势 | 说明 |

|------|------|

|  **零侵入**  | 完全不需要修改核心包代码 |

|  **易升级**  | 核心包升级不影响扩展功能 |

|  **无冲突**  | 多个扩展包可以和谐共存 |

|  **可维护**  | 每个扩展独立维护自己的代码 |

|  **可测试**  | 扩展功能可以独立测试 |

|  **可分发**  | 扩展包可以独立发布和安装 |

### 关键要点

**纯接口驱动，完全平等**：

1. **接口定义**：定义类型行为和属性契约

2. **字符串标识**：所有类型使用字符串作为唯一标识

3. **管理器统一**：注册、创建、查询所有类型

4. **完全平等**：内置类型和扩展类型地位相同

---

**文档版本**: 3.0.0

**最后更新**: 2024-12-24

**维护者**: Red Jasmine Framework Team

**版本说明**：

- v3.0.0: 采用纯接口驱动设计，移除枚举依赖

- v2.0.0: 重构文档结构，直接呈现设计方案而非问题描述

- v1.2.0: 完善扩展类型的实现指南

- v1.1.0: 新增枚举与接口的协作说明

- v1.0.0: 初始版本
